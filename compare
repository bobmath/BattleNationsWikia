#!/usr/bin/env perl
# Compare generated wikitext to what's on the wiki.
# Download pages with slurp script first.
# This uses a very simplistic wikitext parser because I don't feel like
# writing a real one. It mostly works for most of the current pages on
# the wiki.
use strict;
use warnings;

opendir my $DIR, 'units' or die;
my @files = sort grep { !/^\./ } readdir $DIR;
closedir $DIR;

my $picky = 1;

my %ignore;
$ignore{$_} = 1 for (
   'name',
   'next',
   'nextname',
   'prev',
   'prevname',
   'targetbox-rows',
);

my %remap = (
   'line of fire' => 'lof',
   al       => 'animal trainer level',
   bl       => 'barracks level',
   btc      => 'bigfoot training level',
   dmgtype  => 'damage type',
   fl       => 'frontier recruit level',
   gametag  => 'game file name',
   mv       => 'mercenary vault level',
   of       => 'optics facility level',
   other_b  => 'other requirements',
   rl       => 'raider training level',
   ul       => 'unit level',
   ut       => 'unit type',
   vl       => 'vehicle factory level',
);

my %templates = (
   buildcost         => 'buildcost',
   healcost          => 'healcost',
   rank1unitinfobox  => '00profile',
   staticunitinfobox => '00profile',
   unitinfobox       => '00profile',
   unitprofile       => '00profile',
   unitranks9box     => 'unitranks',
   unitranksbox      => 'unitranks',
);

foreach my $file (@files) {
   my $stat1 = read_stat("units/$file") or next;
   my $stat2 = read_stat("wiki/$file") or next;
   print "\n", $file, "\n";
   $stat1->{$_} ||= {} foreach keys %$stat2;
   for my $name (sort keys %$stat1) {
      print $name, "\n";
      my $sec1 = $stat1->{$name};
      my $sec2 = $stat2->{$name} || {};
      $sec1->{$_} //= '' foreach keys  %$sec2;
      for my $key (sort keys %$sec1) {
         my $val1 = $sec1->{$key};
         my $val2 = $sec2->{$key} // '';
         if (lc($val1) ne lc($val2)) {
            if (length($val1) >= 20 || length($val2) >= 20) {
               print "   $key <<$val1>>\n   $key <<$val2>>\n";
            }
            else {
               print "   $key <<$val1>> <<$val2>>\n";
            }
         }
      }
   }
}

sub read_stat {
   my ($file) = @_;
   open my $F, '<', $file or return;
   my (%stat, $sec, $tabber);
   local $_;
   while (<$F>) {
      if (/^\s*\|\s*(\w.*?)\s*=\s*(.*)/) {
         my $key = lc($1);
         my $val = $2;
         $key = $remap{$key} if $remap{$key};
         $val =~ s{\s*(?:<br>\s*)*$}{} unless $picky;
         if ($tabber && $key eq 'name') {
            $sec = new_section($val, \%stat); # new attack (new style)
         }
         elsif ($tabber && $key =~ /^attack\d+$/) {
            next;
         }
         elsif ($sec) {
            $sec->{$key} = $val unless $ignore{$key};
         }
      }
      elsif (/<tabber>/) {
         $tabber = 1;
      }
      elsif (m{</tabber>}) {
         $tabber = 0;
      }
      elsif (/<div.*class="tabbertab"/ && /title="(.*?)"/) {
         $sec = new_section($1, \%stat); # new attack (old style)
      }
      elsif ($tabber && /^\s*(?:\|-\|)?\s*(\w.*?)\s*=/) {
         $sec = new_section($1, \%stat); # new weapon
      }
      elsif (/\{\{(\w+)/) {
         my $templ = $templates{lc $1};
         $sec = $stat{$templ} ||= {} if $templ;
      }
      elsif (/^\s*$/) {
      }
      else {
         $sec = undef;
      }
   }
   return unless %stat;
   return \%stat;
}

sub new_section {
   my ($key, $stats) = @_;
   my $n = 1;
   my $newkey = $key;
   while ($stats->{$newkey}) {
      $newkey = $key . '-' . ++$n;
   }
   return $stats->{$newkey} = {};
}

