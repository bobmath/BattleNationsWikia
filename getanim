#!/usr/bin/env perl
use strict;
use warnings;
use lib 'lib';
use BN;
use Cairo;
use Getopt::Std qw( getopts );
use Image::Magick;

my %opts;
getopts('b:cd:ks:t', \%opts);
my $size = $opts{s} || 100;
die unless $size > 0;
my $background = $opts{b} || 'wiki';
my $delay = $opts{d} || 5;

my %bgmap = (
   critter  => '#ddccaa',
   dirt     => '#c19a6b',
   empire   => '#eb8100',
   fr       => '#eb8100',
   inf      => '#000000',
   player   => '#eb8100',
   raider   => '#bb9966',
   rebel    => '#cccccc',
   sky      => '#87cefa',
   sw       => '#cccccc',
   white    => '#ffffff',
   wiki     => '#f2f2f2',
);
my @background = get_rgb($bgmap{$background} || $background);

die unless @ARGV == 1;
my $name = $ARGV[0];
my $anim = BN::Animation->get($name) or die "Can't find animation $name\n";
my @seq = $anim->sequence();

my (@frames, @scale);
foreach my $n (0 .. $#seq) {
   my $surface = Cairo::ImageSurface->create('argb32', $size, $size);
   my $c = Cairo::Context->create($surface);

   unless ($opts{t}) {
      $c->set_source_rgb(@background);
      $c->rectangle(0, 0, $size, $size);
      $c->fill();
   }

   $c->translate($size/2, $size/2);
   push @scale, $anim->render($c, $seq[$n], $size, 1);
   my $file = sprintf 'frame%03d.png', $n;
   $surface->write_to_png($file);
   push @frames, $file;
}

my $magick = Image::Magick->new();
$magick->Read(@frames);
$magick->Quantize(colors => 256, dither => 'False', global => 'True');
$magick->Write("$name.gif");

my $crop = $opts{c} ? '--crop-transparency' : '';
my $dispose = $opts{t} ? '--disposal=previous' : '';
system("gifsicle --optimize --loop --delay=$delay $dispose"
   . " $crop --batch $name.gif") == 0 or die;

@scale = sort { $a <=> $b } @scale;
printf "Scale: %.2fx\n", $scale[@scale/2];

unlink @frames unless $opts{k};

BEGIN {
   my $xdig = '[0-9a-fA-F]';
   my $xdig2 = $xdig . '{2}';
   sub get_rgb {
      my ($color) = @_;
      if ($color =~ /^#($xdig)($xdig)($xdig)$/o) {
         return (hex($1)/15, hex($2)/15, hex($3)/15);
      }
      elsif ($color =~ /^#($xdig2)($xdig2)($xdig2)$/o) {
         return (hex($1)/255, hex($2)/255, hex($3)/255);
      }
      die 'Invalid color code';
   }
}

