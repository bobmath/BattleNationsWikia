#!/usr/bin/env perl
use strict;
use warnings;
use lib 'lib';
use BN;
use Cairo;
use Getopt::Std qw( getopts );
use POSIX qw( ceil );

my %opts;
getopts('b:cd:ks:t', \%opts);
my $size = $opts{s} || 100;
die unless $size > 0;
my $background = $opts{b} || 'wiki';
my $delay = $opts{d} || 5;

my %bgmap = (
   critter => '#ddccaa',
   empire  => '#eb8100',
   fr      => '#eb8100',
   inf     => '#000000',
   player  => '#eb8100',
   raider  => '#bb9966',
   rebel   => '#cccccc',
   sky     => '#87cefa',
   sw      => '#cccccc',
   wiki    => '#f2f2f2',
);
$background = $bgmap{$background} || $background;

die unless @ARGV == 1;
my $name = $ARGV[0];
my $anim = BN::Animation->get($name) or die;

my $wid = $anim->bmp_width();
my $hgt = $anim->bmp_height();
my $stride = Cairo::Format::stride_for_width('argb32', $wid);
my $source = Cairo::ImageSurface->create_for_data(
   $anim->bitmap('cairo', $stride), 'argb32', $wid, $hgt, $stride);

my @seq = $anim->sequence();
my $grid = ceil(sqrt(@seq));
my $dim = $size * $grid;

my $surface = Cairo::ImageSurface->create('argb32', $dim, $dim);
my $c = Cairo::Context->create($surface);

my $x = 0;
my $y = 0;
my (@frames, @scale);
foreach my $num (@seq) {
   push @frames, "frame_${y}_${x}.ppm";
   $c->save();
   $c->translate(($x + 0.5) * $size, ($y + 0.5) * $size);
   foreach my $quad ($anim->frame($num, $size, 1)) {
      push @scale, sqrt(abs($quad->{det}));
      $c->save();
      $c->transform(Cairo::Matrix->init(@{$quad->{mat}}));
      $c->set_source_surface($source, 0, 0);
      $c->move_to($quad->{x0}, $quad->{y0});
      $c->line_to($quad->{x1}, $quad->{y1});
      $c->line_to($quad->{x2}, $quad->{y2});
      $c->line_to($quad->{x3}, $quad->{y3});
      $c->close_path();
      $c->fill();
      $c->restore();
   }
   $c->restore();
   if (++$x >= $grid) { $x = 0; $y++; }
}

$surface->write_to_png("$name.png");
system("pngtopam -mix -background=$background $name.png | pnmquant -nofs 256"
   . " | pamdice -width=$size -height=$size -outstem=frame") == 0 or die;

my $transparent = $opts{t} ? "-transparent=$background" : '';
my (@gifs, $gif_num);
foreach my $frame (@frames) {
   my $gif = sprintf 'frame%02d.gif', ++$gif_num;
   push @gifs, $gif;
   system("pamtogif $transparent $frame > $gif") == 0 or die;
}
my $crop = $opts{c} ? '--crop-transparency' : '';
my $dispose = $opts{t} ? '--disposal=previous' : '';
system("gifsicle --optimize --loop --delay=$delay $dispose"
   . " $crop @gifs > $name.gif") == 0 or die;

@scale = sort { $a <=> $b } @scale;
printf "Scale: %.2fx\n", $scale[@scale/2];

unless ($opts{k}) {
   while ($y < $grid) {
      push @frames, "frame_${y}_${x}.ppm";
      if (++$x >= $grid) { $x = 0; $y++; }
   }
   unlink @frames, @gifs;
}

