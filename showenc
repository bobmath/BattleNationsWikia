#!/usr/bin/env perl
# Build boss strike battles pages
use strict;
use warnings;
use lib 'lib';
use BN;
use Cairo;
use Image::PNG::Const qw( PNG_COLOR_TYPE_RGB_ALPHA );
use Image::PNG::Libpng qw( read_png_file );
use POSIX qw( ceil floor );

die "Usage: $0 strike_id | encounter_id\n" unless @ARGV == 1;

my %maps = (
   'BattleMapCave.png'  => 'cave',
   'BattleMapSnow.png'  => 'snow',
);

if (my $strike = BN::BossStrike->get($ARGV[0])) {
   write_strike($strike);
}
elsif (my $enc = BN::Encounter->get($ARGV[0])) {
   write_encounter($enc, $ARGV[0]);
}
else {
   die "Encounter $ARGV[0] not found\n";
}

sub write_encounter {
   my ($enc, $id) = @_;
   open my $F, '>', $id or die "Can't write $id: $!\n";
   show_encounter($F, $enc);
   close $F;
}

sub write_strike {
   my ($strike) = @_;

   my %levels;
   foreach my $encounter (@{$strike->{globalEventEncounters}}) {
      add_encounter($encounter, \%levels, 0);
   }
   my $tnum;
   foreach my $tier ($strike->tiers()) {
      ++$tnum;
      foreach my $encounter (@{$tier->{encounters}}) {
         add_encounter($encounter, \%levels, $tnum);
      }
   }

   my %level_tiers;
   foreach my $levels (sort keys %levels) {
      my $tiers = $levels{$levels} or next;
      my @tiers = sort {$a <=> $b} keys %$tiers;
      while (@tiers) {
         my $tnum = shift @tiers;
         my $eids = $tiers->{$tnum} or next;
         my $hinum = $tnum;
         if ($tnum) {
            my $eidstr = join ',', sort keys %$eids;
            while (@tiers) {
               my $nextnum = $tiers[0];
               my $nextids = $tiers->{$nextnum} or last;
               my $nextstr = join ',', sort keys %$nextids;
               last unless $nextstr eq $eidstr;
               $hinum = $nextnum;
               shift @tiers;
            }
         }
         else {
            $tnum = 1;
            $hinum = 10;
         }
         if ($tnum == $hinum) { $level_tiers{$levels}{$tnum} = $eids }
         else { $level_tiers{$levels}{"$tnum-$hinum"} = $eids }
      }
   }

   foreach my $levels (sort keys %level_tiers) {
      my $tiers = $level_tiers{$levels} or next;
      foreach my $tnum (sort keys %$tiers) {
         my $file = "Level_${levels}_tier_${tnum}_battles";
         print "$file\n";
         open my $F, '>', $file or die "Can't write $file: $!";
         my $eids = $tiers->{$tnum} or next;
         my $enum;
         foreach my $eid (sort keys %$eids) {
            show_encounter($F, BN::Encounter->get($eid), 'Battle ' . ++$enum);
         }
         print $F "[[Category:Boss Strike Battles]]\n";
      }
   }

   foreach my $levels (sort keys %level_tiers) {
      my $tiers = $level_tiers{$levels} or next;
      my @links;
      foreach my $tnum (sort keys %$tiers) {
         push @links, "[[/Level $levels tier $tnum battles|tier $tnum]]";
      }
      print "*Level $levels ", join(', ', @links), "\n";
   }
}

sub add_encounter {
   my ($enc, $levels, $tier) = @_;
   my $id = $enc->{encounterId} or return;
   my $max_level = BN::Level->max();
   my $min = $enc->{minLevel} || 1;
   my $max = $enc->{maxLevel} || $max_level;
   $max = $max_level if $max > $max_level;
   $levels->{"$min-$max"}{$tier}{$id} = 1;
}

sub show_encounter {
   my ($F, $enc, $name) = @_;
   my $waves = $enc->waves() or return;
   if ($enc->name()) {
      $name .= ': ' if $name;
      $name .= $enc->name();
   }
   else {
      $name ||= 'Battle';
   }
   print $F "==$name==\n";
   print $F "<tabber>\n";

   my $map = $maps{$enc->map() || ''};

   for my $wave (1 .. @$waves) {
      my @units = sort { $a->{grid} <=> $b->{grid} }
         grep { $_->{grid} } $enc->unit_positions($wave) or next;

      print $F "|-|\n" if $wave > 1;
      print $F "Wave $wave=\n{{BattleMap\n";
      print $F "| map = $map\n" if $map;

      foreach my $u (@units) {
         my $unit = $u->{unit};
         my $tag = get_icon($unit);
         my $link = $unit->wiki_page();
         my $title = $unit->shortname();
         if (my $level = $unit->level()) {
            $title .= " (Level $level)";
         }
         my $grid = $u->{grid};
         print $F "| enemy$grid = $tag\n",
            "| link$grid = $link\n",
            "| title$grid = $title\n";
      }

      print $F "}}\n";
   }

   print $F "</tabber>\n{{Clear}}\n";

   if (my $eff = $enc->environment()) {
      my $text = $eff->effect();
      print $F "Environmental damage: $text\n" if $text;
   }

   my $wnum;
   foreach my $wave (@$waves) {
      $wnum++;
      next unless $wave;
      my %links;
      foreach my $id (@$wave) {
         my $unit = BN::Unit->get($id, 1) or next;
         $links{$unit->shortname()}{$unit->shortlink()}++;
      }
      my @links;
      foreach my $nm (sort keys %links) {
         my $lks = $links{$nm} or next;
         foreach my $link (sort keys %$lks) {
            my $num = $lks->{$link} || 1;
            $link .= ' x ' . $num if $num > 1;
            push @links, $link;
         }
      }
      my $links = join ', ', @links;
      print $F "* Wave $wnum: $links\n" if $links;
   }
}

my %icon_tags;
sub get_icon {
   my ($unit) = @_;
   my $anim = BN::Animation->get($unit->animation()) or return;
   my $tag = $anim->tag();
   $tag =~ s/_idle$//i;
   my $img = ucfirst($tag);
   $tag =~ s/_fr(?:ont)?$//i;

   if (!%icon_tags) {
      $icon_tags{''} = '';
      if (open my $MAP, '<', 'iconmap') {
         local $_;
         while (<$MAP>) {
            $icon_tags{$1} = 1 if /^front\["(.*?)"\]=/;
         }
      }
   }
   return $tag if $icon_tags{$tag};
   $icon_tags{$tag} = 1;

   $img .= '.png';
   print $img, "\n";

   my @box = $anim->box(0);
   my $xmin = floor($box[0]);
   my $xmax = ceil($box[1]);
   my $ymin = floor($box[2]);
   my $ymax = ceil($box[3]);
   my $wid = $xmax - $xmin;
   my $hgt = $ymax - $ymin;

   my $surface = Cairo::ImageSurface->create('argb32', $wid, $hgt);
   my $ctx = Cairo::Context->create($surface);
   $ctx->translate(-$xmin, -$ymin);
   $anim->render($ctx, 0);

   my $tmp = "$img.tmp";
   $surface->write_to_png($tmp) or die;
   crop($tmp, \$xmin, \$ymin, \$wid);
   system("pngcrush -new -q -brute $tmp $img") == 0 or die;
   unlink $tmp;

   open my $MAP, '>>', 'iconmap' or return $tag;
   my $x = -$xmin;
   my $y = -$ymin;
   print $MAP qq(front["$tag"]={x=$x,y=$y,w=$wid,f="$img"}\n);
   return $tag;
}

sub crop {
   my ($file, $xmin_ref, $ymin_ref, $wid_ref) = @_;
   my $png = read_png_file($file);
   my $hdr = $png->get_IHDR();
   die unless $hdr->{color_type} == PNG_COLOR_TYPE_RGB_ALPHA
      && $hdr->{bit_depth} == 8;
   my $rows = $png->get_rows();

   my $top = 0;
   while (@$rows && blankrow($rows->[0])) {
      shift @$rows;
      $top++;
   }
   while (@$rows && blankrow($rows->[-1])) {
      pop @$rows;
   }
   my $left = 0;
   my $right = $hdr->{width} - 1;
   while ($left < $right && blankcol($left, $rows)) {
      $left++;
   }
   while ($left < $right && blankcol($right, $rows)) {
      $right--;
   }

   my $wid = $right - $left + 1;
   if ($wid != $hdr->{width}) {
      my $i = $left * 4;
      my $n = $wid * 4;
      foreach my $row (@$rows) {
         $row = substr($row, $i, $n);
      }
   }
   elsif (@$rows == $hdr->{height}) {
      return;
   }

   $$xmin_ref += $left;
   $$ymin_ref += $top;
   $$wid_ref = $wid;

   $png = Image::PNG::Libpng::create_write_struct();
   $png->set_IHDR({
      width       => $wid,
      height      => scalar(@$rows),
      color_type  => PNG_COLOR_TYPE_RGB_ALPHA,
      bit_depth   => 8,
   });
   $png->set_rows($rows);
   $png->write_png_file($file);
}

sub blankrow {
   my ($row) = @_;
   my $len = length($row);
   for (my $n = 3; $n < $len; $n += 4) {
      return unless ord(substr($row, $n, 1)) <= 5
   }
   return 1;
}

sub blankcol {
   my ($col, $rows) = @_;
   my $n = $col * 4 + 3;
   foreach my $row (@$rows) {
      return unless ord(substr($row, $n, 1)) <= 5
   }
   return 1;
}

