#!/usr/bin/env perl
use strict;
use warnings;
use lib 'lib';
use BN;
use Cairo;
use Getopt::Std qw( getopts );
use Image::Magick;
use List::Util qw( max );
use POSIX qw( ceil );

my %opts;
getopts('a:b:d:efh:ks:t:w:X:x:Y:y:', \%opts) or die 'Invalid args';
my $background = $opts{b} || 'wiki';
my $delay = $opts{d} || 5;
my $front = $opts{f};
my $number = $opts{n};

die "Usage: $0 unit_id\n" unless @ARGV == 1;
my $unit_tag = shift or die;
my $unit = BN::Unit->get($unit_tag) or die "Can't find unit $unit_tag\n";

my %bgmap = (
   critter  => '#ddccaa',
   dirt     => '#c19a6b',
   empire   => '#eb8100',
   fr       => '#eb8100',
   inf      => '#000000',
   player   => '#eb8100',
   raider   => '#bb9966',
   rebel    => '#cccccc',
   sky      => '#87cefa',
   sw       => '#cccccc',
   white    => '#ffffff',
   wiki     => '#f2f2f2',
);
my @background = get_rgb($bgmap{$background} || $background);

my $pat;
$pat = qr/$opts{a}/i if $opts{a};
foreach my $weap ($unit->weapons()) {
   foreach my $attack ($weap->attacks()) {
      draw_attack($weap, $attack) if !$pat || $attack->name() =~ /$pat/;
   }
}

my %seen;
sub draw_attack {
   my ($weap, $attack) = @_;
   my $att_tag = $front ?
      $weap->attack_animation() : $weap->back_attack_animation();
   my $dmg_tag = $opts{t} && ($front ?
      $attack->damage_animation() : $attack->back_damage_animation()) || '';
   return if $seen{"$att_tag $dmg_tag"}++;
   my $att = setup_anim($opts{s}, $att_tag);
   my $dmg = setup_anim($opts{t}, $dmg_tag);

   die unless $att->{width};
   $att->{main} = 1;
   my $num_frames = @{$att->{seq}};
   my $dmg_start = $opts{e} ? $num_frames : $weap->damage_animation_delay();
   unshift @{$dmg->{seq}}, (undef) x $dmg_start if $dmg_start;
   my $dmg_frames = @{$dmg->{seq}};
   if ($dmg_frames > $num_frames) {
      push @{$att->{seq}}, ($att->{seq}[0]) x ($dmg_frames - $num_frames);
      $num_frames = $dmg_frames;
   }

   my $width = $opts{w} || ceil($att->{width} + $dmg->{width}/2);
   my $height = $opts{h} || ceil($att->{height} + $dmg->{height}/2);

   $att->{x} = $opts{x};
   $att->{y} = $opts{y};
   $dmg->{x} = $opts{X};
   $dmg->{y} = $opts{Y};

   my @anims = $front ? ($dmg, $att) : ($att, $dmg);
   $anims[0]{x} //= $anims[0]{width} / 2 + 1;
   $anims[0]{y} //= $height - $anims[0]{height} / 2 - 1;
   $anims[1]{x} //= $width - $anims[1]{width} / 2 - 1;
   $anims[1]{y} //= $anims[1]{height} / 2 + 1;

   my (@frames, @scale);
   for my $num (0 .. $num_frames-1) {
      my $surface = Cairo::ImageSurface->create('argb32', $width, $height);
      my $c = Cairo::Context->create($surface);
      $c->set_source_rgb(@background);
      $c->rectangle(0, 0, $width, $height);
      $c->fill();

      foreach my $anim (@anims) {
         my $fnum = $anim->{seq}[$num];
         next unless defined $fnum;
         $c->save();
         $c->translate($anim->{x}, $anim->{y});
         my $scale = $anim->{anim}->render($c, $fnum, $anim->{size}, 1);
         $c->restore();
         push @scale, $scale if $anim->{main} && defined($scale);
      }

      my $file = sprintf 'frame%03d.png', $num;
      $surface->write_to_png($file) or die;
      push @frames, $file;
   }

   my $file = $attack->filename($unit) . '.gif';
   unlink $file;
   @scale = sort { $a <=> $b } @scale;
   printf "%s: %.2fx\n", $file, $scale[@scale/2];

   my $magick = Image::Magick->new();
   $magick->Read(@frames);
   $magick->Quantize(colors => 256, dither => 'False', global => 'True');
   $magick->Write($file);
   unlink @frames unless $opts{k};

   system("gifsicle --optimize --loop --delay=$delay --batch $file") == 0
      or die;
}

sub setup_anim {
   my ($size, $tag) = @_;
   if (!$tag) {
      return { width=>0, height=>0, seq=>[] };
   }
   $size ||= 100;
   my %info;
   $info{anim} = BN::Animation->get($tag) or die "Animation $tag not found\n";
   my ($xlo, $xhi, $ylo, $yhi) = $info{anim}->box();
   $info{size} = $size;
   $info{width} = $xhi - $xlo;
   $info{height} = $yhi - $ylo;
   if ($info{width} >= $info{height}) {
      $info{height} *= $size / $info{width};
      $info{width} = $size;
   }
   else {
      $info{width} *= $size / $info{height};
      $info{height} = $size;
   }
   $info{seq} = [ $info{anim}->sequence() ];
   return \%info;
}

BEGIN {
   my $xdig = '[0-9a-fA-F]';
   my $xdig2 = $xdig . '{2}';
   sub get_rgb {
      my ($color) = @_;
      if ($color =~ /^#($xdig)($xdig)($xdig)$/o) {
         return (hex($1)/15, hex($2)/15, hex($3)/15);
      }
      elsif ($color =~ /^#($xdig2)($xdig2)($xdig2)$/o) {
         return (hex($1)/255, hex($2)/255, hex($3)/255);
      }
      die 'Invalid color code';
   }
}

