#!/usr/bin/env perl
# Compare generated wikitext for units to what's on the wiki.
# Download pages with slurp script first.
# This uses a very simplistic wikitext parser because I don't feel like
# writing a real one. It mostly works for most of the current pages on
# the wiki.
use strict;
use warnings;

opendir my $DIR, 'data/units' or die;
my @files = sort grep { !/^\./ } readdir $DIR;
closedir $DIR;

my $picky = 1;

my %ignore;
$ignore{$_} = 1 for qw(
   image
   name
   next
   nextname
   prev
   prevname
   targetbox-rows
   weaponicon
);

my %templates = (
   buildcost         => 'buildcost',
   healcost          => 'healcost',
   unitinfobox       => '00profile',
   unitprofile       => '00profile',
   unitranks9box     => 'unitranks',
   unitranksbox      => 'unitranks',
);

my %namemap;
if (open my $F, '<', 'namemap') {
   while (<$F>) {
      $namemap{"data/$1"} = $2 if /^\s*(.*?)\s*=\s*(.*?)\s*$/;
   }
}

foreach my $file (@files) {
   my $file1 = "data/units/$file";
   my $file2;
   if ($file2 = $namemap{$file1}) {
      $file2 =~ s/['"\/]//g;
      $file2 =~ s/\s+/_/g;
      $file2 = "wiki/$file2";
   }
   else {
      $file2 = "wiki/$file";
   }
   my $stat1 = read_stat($file1) or next;
   my $stat2 = read_stat($file2) or next;
   print "\n", $file, "\n";
   $stat1->{$_} ||= {} foreach keys %$stat2;
   for my $name (sort keys %$stat1) {
      print $name, "\n";
      my $sec1 = $stat1->{$name};
      my $sec2 = $stat2->{$name} || {};
      $sec1->{$_} //= '' foreach keys  %$sec2;
      for my $key (sort keys %$sec1) {
         my $val1 = $sec1->{$key};
         my $val2 = $sec2->{$key} // '';
         if (lc($val1) ne lc($val2)) {
            if (length($val1) >= 20 || length($val2) >= 20) {
               print "   $key <<$val1>>\n   $key <<$val2>>\n";
            }
            else {
               print "   $key <<$val1>> <<$val2>>\n";
            }
         }
      }
   }
}

sub read_stat {
   my ($file) = @_;
   open my $F, '<', $file or return;
   my (%stat, $sec, $tabber);
   local $_;
   while (<$F>) {
      if (/^\s*\|\s*(\w.*?)\s*=\s*(.*)/) {
         my $key = lc($1);
         my $val = $2;
         $val =~ s{\s*(?:<br>\s*)*$}{} unless $picky;
         if ($tabber && $key eq 'name') {
            $sec = new_section($val, \%stat); # new attack (new style)
         }
         elsif ($tabber && $key =~ /^attack\d+$/) {
            next;
         }
         elsif ($sec) {
            $sec->{$key} = $val unless $ignore{$key};
         }
      }
      elsif (/<tabber>/) {
         $tabber = 1;
      }
      elsif (m{</tabber>}) {
         $tabber = 0;
      }
      elsif (/<div.*class="tabbertab"/ && /title="(.*?)"/) {
         $sec = new_section($1, \%stat); # new attack (old style)
      }
      elsif ($tabber && /^\s*(?:\|-\|)?\s*(\w.*?)\s*=/) {
         $sec = new_section($1, \%stat); # new weapon
      }
      elsif (/\{\{(\w+)/) {
         my $templ = $templates{lc $1};
         $sec = $stat{$templ} ||= {} if $templ;
      }
      elsif (/^\s*$/) {
      }
      else {
         $sec = undef;
      }
   }
   return unless %stat;
   return \%stat;
}

sub new_section {
   my ($key, $stats) = @_;
   $key =~ s/\s+$//;
   $key =~ s/\s*\(.*\)$//;
   my $n = 1;
   my $newkey = $key;
   while ($stats->{$newkey}) {
      $newkey = $key . '-' . ++$n;
   }
   return $stats->{$newkey} = {};
}

