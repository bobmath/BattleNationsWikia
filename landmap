use strict;
use warnings;
use lib 'lib';
use BN;
use Cairo;
use Getopt::Std;

my %opts;
getopts('t', \%opts) or die 'bad opts';
my $TILENUMS = $opts{t};

my $mapname = $ARGV[0];
unless ($mapname) {
   my $landlist = BN::File->json('LandList.json');
   if (my $list = $landlist->{landList}) {
      print 'Maps: ', join(', ', sort @$list), "\n";
   }
   die 'no map selected';
}

my $map = BN::File->json($mapname . '.json');
my $tilefile = $map->{tileLayoutFile} or die;
my $tileset = $map->{tileSet} or die;
$tileset =~ s/\.pvr$//;
my $tiles = BN::File->json($tilefile);
$tiles = $tiles->{map} or die;
my $layer = $tiles->{layers}[0] or die;
my $data = $layer->{data} or die;
my $wid = $layer->{width} or die;
my $hgt = $layer->{height} or die;

my $Xmin = $wid;
my $Ymin = $hgt;
my $Xmax = 0;
my $Ymax = 0;
my $i = 0;
for my $y (0 .. $hgt-1) {
   for my $x (0 .. $wid-1) {
      next unless $data->[$i++];
      my $X = $x - $y;
      my $Y = $y + $y;
      $Xmin = $X if $X < $Xmin;
      $Xmax = $X if $X > $Xmax;
      $Ymin = $Y if $Y < $Ymin;
      $Ymax = $Y if $Y > $Ymax;
   }
}

my $im_wid = ($Xmax - $Xmin + 2) * 60 + 16;
my $im_hgt = ($Ymax - $Ymin + 2) * 30 + 8;

my $surface = Cairo::ImageSurface->create('argb32', $im_wid, $im_hgt);
my $ctx = Cairo::Context->create($surface);

my $tilesetfile = "../bg/${tileset}_split.png";
my $tileimg = Cairo::ImageSurface->create_from_png($tilesetfile) or die;

$i = 0;
for my $y (0 .. $hgt-1) {
   for my $x (0 .. $wid-1) {
      my $tile = $data->[$i++] or next;
      $tile--;
      my $tx = ($tile & 7) << 7;
      my $ty = ($tile >> 3) << 6;
      my $X = ($x - $y - $Xmin) * 60;
      my $Y = ($x + $y - $Ymin) * 30;
      $ctx->set_source_surface($tileimg, $X - $tx, $Y - $ty);
      $ctx->rectangle($X+2, $Y+1, 124, 62);
      $ctx->fill();
      if ($TILENUMS) {
         $ctx->set_source_rgb(1, 1, 1);
         $ctx->move_to($X+60, $Y+30);
         $ctx->show_text($tile);
      }
   }
}

if (my $buildings = $map->{buildings}) {
   my %roads;
   my $xoff = $wid/2 + 0.5;
   my $yoff = $hgt/2 - 0.5;
   foreach my $info (@$buildings) {
      my $type = $info->{type};
      my $bld = BN::Building->get($type) or next;
      $info->{bld} = $bld;
      my $x = $xoff - $info->{x}/3;
      my $y = $yoff - $info->{y}/3;
      $info->{X} = ($x - $y - $Xmin) * 60;
      $info->{YY} = $info->{Y} = ($x + $y - $Ymin) * 30;
      $info->{YY} += 15 if $type =~ /^deco_egg_/; # kludge
      $info->{YY} -= 15 if $type =~ /^deco_dirtroad_/;
      if (my $road = $bld->{BNSmartRoad}) {
         $roads{"$info->{x},$info->{y}"} = $road->{baseAnimationName};
      }
   }
   foreach my $info (sort { $a->{YY} <=> $b->{YY} } @$buildings) {
      my $bld = $info->{bld} or next;
      my $animname = $bld->animation('Default') or next;
      if (my $road = $bld->{BNSmartRoad}) {
         $animname = smart_road($info, $road, \%roads) || $animname;
      }
      my $anim = eval { BN::Animation->get($animname) };
      die "Can't load $animname: $@" if $@;
      next unless $anim;
      $ctx->save();
      $ctx->translate($info->{X}, $info->{Y});
      $ctx->scale(-1, 1) if $info->{flip};
      $anim->render($ctx, 0);
      $ctx->restore();
   }
}

$surface->write_to_png($mapname . '.png');

sub smart_road {
   my ($info, $road, $roads) = @_;
   my $x = $info->{x};
   my $y = $info->{y};
   my $wid = $road->{width} or return;
   my $base = $road->{baseAnimationName} or return;
   my $anim = $base . '_';
   $anim .= ($roads->{($x+$wid).','.($y)}||'') eq $base ? 'x' : 'o';
   $anim .= ($roads->{($x).','.($y+$wid)}||'') eq $base ? 'x' : 'o';
   $anim .= ($roads->{($x-$wid).','.($y)}||'') eq $base ? 'x' : 'o';
   $anim .= ($roads->{($x).','.($y-$wid)}||'') eq $base ? 'x' : 'o';
   return $anim;
}

