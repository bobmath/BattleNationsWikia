#!/usr/bin/env perl
# Make maps of aoe damage.
use strict;
use warnings;
use lib 'lib';
use BN;
use Cairo;
use Getopt::Std qw( getopts );
use POSIX qw( ceil );

my $grid_size = 40;
my $max_width = 300;
my $max_height = 200;
my $x_factor = 0.86603;
my $y_factor = 0.5;

my %opts;
getopts('a:i:u:y:', \%opts) or die "Invalid options\n";

die "usage: $0 unit-ids\n" unless @ARGV;
draw_aoe($_) foreach @ARGV;

sub draw_aoe {
   my ($id) = @_;
   my $unit = BN::Unit->get($id) or die "Can't find unit $id\n";
   foreach my $weapon ($unit->weapons()) {
      foreach my $attack ($weapon->attacks()) {
         draw_attack($unit, $attack);
      }
   }
}

sub draw_attack {
   my ($unit, $attack) = @_;
   my @plots = ( get_aoe($attack->target_area()),
      get_aoe($attack->damage_area()) ) or return;
   if (@plots == 2 && !$plots[0]{random}) {
      @plots = convolve(@plots);
   }
   $plots[0]{range} = $attack->max_range();

   calc_size($_, $unit) foreach @plots;
   my $width = 0;
   my $height = 0;
   foreach my $plot (@plots) {
      $width += 4 if $width;
      $plot->{xcenter} += $width;
      $width += $plot->{width};
      $height = $plot->{height} if $plot->{height} > $height;
   }

   my $file = $unit->shortname();
   if ($unit->side() eq 'Hostile') {
      $file .= $unit->level() // '';
   }
   $file .= '_' . $attack->name();
   $file =~ s/\W+//g;
   my $temp = $file . '-temp.png';
   $file .= '.png';
   print "$file  $width x $height\n";

   my $surface = Cairo::ImageSurface->create('argb32', $width, $height);
   my $c = Cairo::Context->create($surface);
   draw_grid($c, $height, $unit, $attack, $_) foreach @plots;
   $c->show_page();
   $surface->write_to_png($temp);
   system("pngcrush -q -new -brute -rem alla $temp $file") == 0 or die;
   unlink $temp;
}

sub draw_grid {
   my ($c, $height, $unit, $attack, $plot) = @_;
   $c->save();
   $c->transform(Cairo::Matrix->init($plot->{xscale}, $plot->{yscale},
      -$plot->{xscale}, $plot->{yscale}, $plot->{xcenter},
      int($plot->{ycenter} + ($height - $plot->{height})/2)));
   $c->set_line_width(1 / $plot->{xscale});
   $c->set_font_size(0.35);

   my ($scale, $tag, @center, @color);
   if ($plot->{random}) {
      $scale = 100;
      $tag = '%';
      @color = ( 0, 1, 1 );
      @center = ( 0, 0.8, 0.8 );
   }
   else {
      my $rank = ($unit->ranks())[$attack->rank()-1];
      my $power = $rank ? $rank->power() : 0;
      my ($min, $max) = $attack->adjusted_dmg($power);
      $scale = ($min + $max) / 2;
      $tag = '';
      @color = ( 1, 1, 0 );
      @center = ( 1, 0.3, 0.3 );
   }

   foreach my $sq (@{$plot->{squares}}) {
      next unless $sq->{visible};
      my $x = $sq->{x};
      my $y = $sq->{y};
      $c->set_source_rgb($x || $y ? @color : @center);
      $c->rectangle($x - 0.5, $y - 0.5, 1, 1);
      $c->fill();
      $c->set_source_rgb(0, 0, 0);
      $c->rectangle($x - 0.5, $y - 0.5, 1, 1);
      $c->stroke();

      my $val = $sq->{val} * $scale;
      $val = 1 if $val < 1;
      $val = sprintf '%.0f%s', $val, $tag;
      my $size = $c->text_extents($val);
      $c->move_to($x - $size->{width}/2, $y + $size->{height}/2);
      $c->show_text($val);
   }

   if (defined(my $unitpos = $plot->{unitpos})) {
      my ($x, $y) = $c->user_to_device(0, $unitpos);
      $c->restore();
      $c->save();
      draw_icon($c, $x, $y, $plot);
   }

   $c->restore();
}

sub find_icon {
   my ($unit, $plot, $flip) = @_;
   $plot->{anim} = BN::Animation->get(
      $opts{a} || ($flip ? $unit->animation() : $unit->back_animation()))
      and return 1;

   my $file = $opts{i} || ($flip ? $unit->icon() : $unit->back_icon());
   $file =~ s{^bundle://}{};
   my @files = BN::File->glob("$file*") or return;

   my $best = shift @files;
   if (@files) {
      my $size = -s $best;
      foreach my $test (@files) {
         my $test_size = -s $test;
         if ($test_size > $size) {
            $size = $test_size;
            $best = $test;
         }
      }
   }

   $plot->{icon} = $best and return 1;
   return;
}

sub draw_icon {
   my ($c, $x, $y, $plot) = @_;
   my $size = $plot->{xscale} * ($opts{u} || 1.6);
   my $pos = $plot->{yscale} * ($opts{y} || 1.6);
   if (my $anim = $plot->{anim}) {
      my $wid = $anim->bmp_width();
      my $hgt = $anim->bmp_height();
      my $stride = Cairo::Format::stride_for_width('argb32', $wid);
      my $src = Cairo::ImageSurface->create_for_data(
         $anim->bitmap('cairo', $stride), 'argb32', $wid, $hgt, $stride);
      $c->translate($x, $y + $pos);
      foreach my $quad ($anim->frame(0, $size)) {
         $c->save();
         $c->transform(Cairo::Matrix->init(@{$quad->{mat}}));
         $c->set_source_surface($src, 0, 0);
         $c->move_to($quad->{x0}, $quad->{y0});
         $c->line_to($quad->{x1}, $quad->{y1});
         $c->line_to($quad->{x2}, $quad->{y2});
         $c->line_to($quad->{x3}, $quad->{y3});
         $c->close_path();
         $c->fill();
         $c->restore();
      }
   }
   elsif (my $file = $plot->{icon}) {
      my $icon = Cairo::ImageSurface->create_from_png($file);
      my $width = $icon->get_width();
      my $height = $icon->get_height();

      my ($dest_width, $dest_height);
      if ($width >= $height) {
         $dest_width = $size;
         $dest_height = $dest_width * $height / $width;
      }
      else {
         $dest_height = $size;
         $dest_width = $dest_height * $width / $height;
      }

      $c->translate($x - 0.5 * $dest_width, $y - 0.6 * $dest_height);
      my $scale = $dest_width / $width;
      $c->scale($scale, $scale);

      $c->set_source_surface($icon, 0, 0);
      $c->rectangle(0, 0, $width, $height);
      $c->fill();
   }
}

sub calc_size {
   my ($plot, $unit) = @_;
   my ($ymax, $ymin, $unitpos);
   if ($plot->{type} eq 'Weapon') {
      $ymax = -1;
      $ymin = -5;
      $unitpos = 0 if $plot->{range};
   }
   else {
      $ymax = 2;
      $ymin = -2;
      if (my $range = $plot->{range}) {
         $ymax = $range-1 if $ymax >= $range;
         $unitpos = $range;
      }
   }

   my $flip = $unit->side() eq 'Hostile';

   my $yhi = 0;
   my $left = 0;
   my $right = 0;
   my $top = 0;
   my $bottom = 0;
   foreach my $sq (@{$plot->{squares}}) {
      next if abs($sq->{x}) > 4;
      next if $sq->{y} < $ymin || $sq->{y} > $ymax;
      next if abs($sq->{x}) == 4 && $sq->{y} == $ymin;
      $yhi = $sq->{y} if $sq->{y} > $yhi;
      $sq->{visible} = 1;

      if ($flip) {
         $sq->{x} = -$sq->{x};
         $sq->{y} = -$sq->{y};
      }

      my $x = $sq->{x} - $sq->{y};
      my $y = $sq->{x} + $sq->{y};
      $left = $x if $x < $left;
      $right = $x if $x > $right;
      $top = $y if $y < $top;
      $bottom = $y if $y > $bottom;
   }

   if (defined($unitpos) && find_icon($unit, $plot, $flip)) {
      $yhi += 2;
      $unitpos = $yhi if $unitpos > $yhi;
      my ($x, $y);
      if ($flip) {
         $unitpos = -$unitpos;
         $x = -$unitpos;
         $y = $unitpos - 1;
      }
      else {
         $x = -$unitpos;
         $y = $unitpos;
      }
      $left = $x if $x < $left;
      $right = $x if $x > $right;
      $top = $y if $y < $top;
      $bottom = $y if $y > $bottom;
      $plot->{unitpos} = $unitpos;
   }

   my $width = $right - $left + 2;
   my $height = $bottom - $top + 2;
   my $size = $grid_size;
   my ($xscale, $yscale, $pixwid, $pixhgt);
   my $calc_size = sub {
      $xscale = $size * $x_factor;
      $yscale = $size * $y_factor;
      $pixwid = ceil($width * $xscale + 2);
      $pixhgt = ceil($height * $yscale + 2);
   };
   $calc_size->();
   if ($pixwid > $max_width) {
      $size = ($max_width - 2.01) / $x_factor / $width;
      $calc_size->();
   }
   if ($pixhgt > $max_height) {
      $size = ($max_height - 2.01) / $y_factor / $height;
      $calc_size->();
   }
   $plot->{width}   = $pixwid;
   $plot->{height}  = $pixhgt;
   $plot->{xscale}  = $xscale;
   $plot->{yscale}  = $yscale;
   $plot->{xcenter} = int($xscale * (1 - $left) + 1.5);
   $plot->{ycenter} = int($yscale * (1 -  $top) + 1.5);
}

sub convolve {
   my ($targ_area, $dmg_area) = @_;
   my $targ_squares = $targ_area->{squares};
   my $dmg_squares = $dmg_area->{squares};

   my %map;
   foreach my $targ (@$targ_squares) {
      foreach my $dmg (@$dmg_squares) {
         my $x = $targ->{x} + $dmg->{x};
         my $y = $targ->{y} + $dmg->{y};
         $map{$y}{$x} += $targ->{val} * $dmg->{val};
      }
   }

   my @squares;
   foreach my $y (sort { $a <=> $b } keys %map) {
      my $row = $map{$y} or die;
      foreach my $x (sort { $a <=> $b } keys %$row) {
         push @squares, { x=>$x, y=>$y, val=>$row->{$x} };
      }
   }

   return { squares=>\@squares, type=>$targ_area->{type} };
}

sub get_aoe {
   my ($area) = @_;
   return unless $area;
   my $squares = $area->{data} or return;

   my ($rand, $weight);
   if ($rand = $area->{random}) {
      $weight += $_->{weight} foreach @$squares;
   }

   my @squares;
   foreach my $square (@$squares) {
      my $pos = $square->{pos} or next;
      push @squares, {
         x => -$pos->{x}, y => $pos->{y},
         val => $rand ? $square->{weight} / $weight
                      : $square->{damagePercent} / 100,
      };
   }
   return unless @squares > 1;

   return { squares=>\@squares, random=>$rand, type=>$area->{type}//'' };
}

