#!/usr/bin/env perl
# Build boss strike battles pages
use strict;
use warnings;
use lib 'lib';
use BN;
use Cairo;
use Image::PNG::Const qw( PNG_COLOR_TYPE_RGB_ALPHA );
use Image::PNG::Libpng qw( read_png_file );
use POSIX qw( ceil floor );

die "Usage: $0 strike_id\n" unless @ARGV == 1;
my $strike = BN::BossStrike->get($ARGV[0]) or die "Boss strike not found\n";

my %levels;
foreach my $encounter (@{$strike->{globalEventEncounters}}) {
   add_encounter($encounter, \%levels, 0);
}
my $tnum;
foreach my $tier ($strike->tiers()) {
   ++$tnum;
   foreach my $encounter (@{$tier->{encounters}}) {
      add_encounter($encounter, \%levels, $tnum);
   }
}

my %level_tiers;
foreach my $levels (sort keys %levels) {
   my $tiers = $levels{$levels} or next;
   my @tiers = sort {$a <=> $b} keys %$tiers;
   while (@tiers) {
      my $tnum = shift @tiers;
      my $eids = $tiers->{$tnum} or next;
      my $hinum = $tnum;
      if ($tnum) {
         my $eidstr = join ',', sort keys %$eids;
         while (@tiers) {
            my $nextnum = $tiers[0];
            my $nextids = $tiers->{$nextnum} or last;
            my $nextstr = join ',', sort keys %$nextids;
            last unless $nextstr eq $eidstr;
            $hinum = $nextnum;
            shift @tiers;
         }
      }
      else {
         $tnum = 1;
         $hinum = 10;
      }
      if ($tnum == $hinum) { $level_tiers{$levels}{$tnum} = $eids }
      else { $level_tiers{$levels}{"$tnum-$hinum"} = $eids }
   }
}

foreach my $levels (sort keys %level_tiers) {
   my $tiers = $level_tiers{$levels} or next;
   foreach my $tnum (sort keys %$tiers) {
      my $file = "Level_${levels}_tier_${tnum}_battles";
      print "$file\n";
      open my $F, '>', $file or die "Can't write $file: $!";
      my $eids = $tiers->{$tnum} or next;
      my $enum;
      foreach my $eid (sort keys %$eids) {
         show_encounter($F, BN::Encounter->get($eid), ++$enum);
      }
      print $F "[[Category:Boss Strike Battles]]\n";
   }
}

foreach my $levels (sort keys %level_tiers) {
   my $tiers = $level_tiers{$levels} or next;
   my @links;
   foreach my $tnum (sort keys %$tiers) {
      push @links, "[[/Level $levels tier $tnum battles|tier $tnum]]";
   }
   print "*Level $levels ", join(', ', @links), "\n";
}

sub add_encounter {
   my ($enc, $levels, $tier) = @_;
   my $id = $enc->{encounterId} or return;
   my $max_level = BN::Level->max();
   my $min = $enc->{minLevel} || 1;
   my $max = $enc->{maxLevel} || $max_level;
   $max = $max_level if $max > $max_level;
   $levels->{"$min-$max"}{$tier}{$id} = 1;
}

sub show_encounter {
   my ($F, $enc, $num) = @_;
   my $waves = $enc->waves() or return;
   print $F "==Battle $num==\n";
   print $F "<tabber>\n";

   for my $wave (1 .. @$waves) {
      my @units = sort { $a->{grid} <=> $b->{grid} }
         grep { $_->{grid} } $enc->unit_positions($wave) or next;

      print $F "|-|\n" if $wave > 1;
      print $F "Wave $wave=\n{{BattleMap\n";

      foreach my $u (@units) {
         my $tag = get_icon($u->{unit});
         my $link = $u->{unit}->wiki_page();
         print $F "| enemy$u->{grid} = $tag\n",
            "| link$u->{grid} = $link\n";
      }

      print $F "}}\n";
   }

   print $F "</tabber>\n{{Clear}}\n";

   my $wnum;
   foreach my $wave (@$waves) {
      $wnum++;
      next unless $wave;
      my %links;
      foreach my $id (@$wave) {
         my $unit = BN::Unit->get($id, 1) or next;
         $links{$unit->shortname()}{$unit->shortlink()}++;
      }
      my @links;
      foreach my $nm (sort keys %links) {
         my $lks = $links{$nm} or next;
         foreach my $link (sort keys %$lks) {
            my $num = $lks->{$link} || 1;
            $link .= ' x ' . $num if $num > 1;
            push @links, $link;
         }
      }
      my $links = join ', ', @links;
      print $F "* Wave $wnum: $links\n" if $links;
   }
}

my %icon_tags;
sub get_icon {
   my ($unit) = @_;
   my $anim = BN::Animation->get($unit->animation()) or return;
   my $tag = $anim->tag();
   $tag =~ s/_idle$//i;
   my $img = ucfirst($tag);
   $tag =~ s/_fr(?:ont)?$//i;

   if (!%icon_tags) {
      $icon_tags{''} = '';
      if (open my $MAP, '<', 'iconmap') {
         local $_;
         while (<$MAP>) {
            $icon_tags{$1} = 1 if /^front\["(.*?)"\]=/;
         }
      }
   }
   return $tag if $icon_tags{$tag};
   $icon_tags{$tag} = 1;

   $img .= '.png';
   print $img, "\n";

   my @box = $anim->box(0);
   my $xmin = floor($box[0]);
   my $xmax = ceil($box[1]);
   my $ymin = floor($box[2]);
   my $ymax = ceil($box[3]);
   my $wid = $xmax - $xmin;
   my $hgt = $ymax - $ymin;

   my $surface = Cairo::ImageSurface->create('argb32', $wid, $hgt);
   my $ctx = Cairo::Context->create($surface);
   $ctx->translate(-$xmin, -$ymin);
   $anim->render($ctx, 0);

   my $tmp = "$img.tmp";
   $surface->write_to_png($tmp) or die;
   crop($tmp, \$xmin, \$ymin, \$wid);
   system("pngcrush -new -q -brute $tmp $img") == 0 or die;
   unlink $tmp;

   open my $MAP, '>>', 'iconmap' or return $tag;
   my $x = -$xmin;
   my $y = -$ymin;
   print $MAP qq(front["$tag"]={x=$x,y=$y,w=$wid,f="$img"}\n);
   return $tag;
}

sub crop {
   my ($file, $xmin_ref, $ymin_ref, $wid_ref) = @_;
   my $png = read_png_file($file);
   my $hdr = $png->get_IHDR();
   die unless $hdr->{color_type} == PNG_COLOR_TYPE_RGB_ALPHA
      && $hdr->{bit_depth} == 8;
   my $rows = $png->get_rows();

   my $top = 0;
   while (@$rows && blankrow($rows->[0])) {
      shift @$rows;
      $top++;
   }
   while (@$rows && blankrow($rows->[-1])) {
      pop @$rows;
   }
   my $left = 0;
   my $right = $hdr->{width} - 1;
   while ($left < $right && blankcol($left, $rows)) {
      $left++;
   }
   while ($left < $right && blankcol($right, $rows)) {
      $right--;
   }

   my $wid = $right - $left + 1;
   if ($wid != $hdr->{width}) {
      my $i = $left * 4;
      my $n = $wid * 4;
      foreach my $row (@$rows) {
         $row = substr($row, $i, $n);
      }
   }
   elsif (@$rows == $hdr->{height}) {
      return;
   }

   $$xmin_ref += $left;
   $$ymin_ref += $top;
   $$wid_ref = $wid;

   $png = Image::PNG::Libpng::create_write_struct();
   $png->set_IHDR({
      width       => $wid,
      height      => scalar(@$rows),
      color_type  => PNG_COLOR_TYPE_RGB_ALPHA,
      bit_depth   => 8,
   });
   $png->set_rows($rows);
   $png->write_png_file($file);
}

sub blankrow {
   my ($row) = @_;
   my $len = length($row);
   for (my $n = 3; $n < $len; $n += 4) {
      return unless ord(substr($row, $n, 1)) <= 5
   }
   return 1;
}

sub blankcol {
   my ($col, $rows) = @_;
   my $n = $col * 4 + 3;
   foreach my $row (@$rows) {
      return unless ord(substr($row, $n, 1)) <= 5
   }
   return 1;
}

